#### 인터럽트

<u></u>



- 인터럽트란

  ------

  - CPU 외부의 hw적인 요구에 의해 정상적인 **프로그램 실행 순서를 변경**하여 보다 **시급한 작업을 먼저 수행한 후 다시 원래의 프로그램으로 복귀**하는 것

  - 비동기적으로 발생하는 주변 장치의 서비스 요청에 CPU가 가장 빠르게 대응할 수 있는 방법

  - CPU(고속)와 주변장치(저속) 사이에서 효율적으로 일 수행

  - 인터럽트 발생 시 나중에 돌아올 **복귀 주소**가 자동적으로 스택에 저장되었다가, 인터럽트 서비스루틴의 마지막에 복귀 명령을 만나면 다시 자동적으로 복귀주소로 돌아온다

    ![Interrupt-1](https://raw.githubusercontent.com/Songwonseok/CS-Study/main/OS/images/Interrupt-1.PNG)



- **인터럽트의 종류**

  ------

  **1) 하드웨어 인터럽트**

  - 내부 인터럽트(=Trap)
    - **잘못된 명령이나 잘못된 데이터를 사용할 때 발생**
    - 프로그램 검사 인터럽트(Program check interrupt)
      - Division by zero
      - Overflow / Underflow
      - 기타 프로그램 인터럽트
  - 외부 인터럽트
    - 전원 이상 인터럽트(Power fail interrupt) : 정전, 파워 이상 등
    - 기계 착오 인터럽트 : CPU의 기능적 오류
    - 외부 인터럽트(External)
      - 자원이 할당된 시간이 다 끝난 경우
      - 키보드로 인터럽트 키를 누른 경우(ctrl+alt+del)
      - 외부장치로부터 인터럽트 요청이 있는 경우
    - 입출력 인터럽트
      - IO장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경ㅇ우
      - IO 데이터에 이상이 있는 경우

  

  **2)소프트웨어 인터럽트**

  - 프로그램 처리 중 명령의 요청에 의해 발생
  - 대표적 형태 -> 프로그램에서 감시 프로그램(SVC) 호출
  - SVC(SuperVisor Call)
    - 사용자가 프로그램을 실행시키거나 감시프로그램을 호출하는 동작을 수행하는 경우
    - 복잡한 IO 처리를 하는 경우





- **인터럽트 동작 순서**

  ------

  1. **인터럽트 요청**

  2. **프로그램 실행 중단**(현재 실행중이던 Micro Operation까지 수행)

  3. **현재의 프로그램 상태 보존** : PCB(Process Control Block), PC(Program Counter) 등

  4. **인터럽트 처리 루틴 실행**(인터럽트를 요청한 장치 식별)

  5. **인터럽트 서비스 루틴 실행**

     - 인터럽트 원인 파악, 실질적 작업 수행, 처리기 레지스터 상태 보존

     - 서비스루틴 수행 중 우선순위가 더 높은 인터럽트 발생 시 -> 재귀적으로 1~5 수행
     - 인터럽트 서비스 루틴 실행 시 인터럽트 플래그(IF)를 0으로 하면 인터럽트 발생 방지

  6. **상태복구**(인터럽트 발생 시 저장해둔 PC를 다시 복구)

  7. **중단된 프로그램 실행 재개**(PC 값을 이용해 이전에 수행중이던 프로그램을 재개)





- **인터럽트 우선순위**

  ------

  - 인터럽트 동시 발생 or 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별 필요
    1. 전원 이상
    2. 기계 착오
    3. 외부 신호
    4. 입출력
    5. 명령어 잘못
    6. 프로그램 검사
    7. SVC
  - 일반적으로 ` HW 인터럽트 > SW 인터럽트`
  - `외부 인터럽트 > 내부 인터럽트`



- 우선순위 판별 방법

  ------

  - **소프트웨어적 방법(Polling)**

    - **인터럽트 요청 플래그를 차례로 비교**해 우선순위가 가장 높은 인터럽트 자원을 찾고 이에 해당하는 인터럽트 서비스 루틴 실행

    - 속도가 빠른 장치 높은 등급 부여

    - 우선순위 변경이 쉬움

    - 많은 인터럽트가 있을 경우 HW적인 방법에 비해 우선순위 판단 속도가 느림

    - ------

      회로 간단, 융통성, 별도의 HW 필요 없음

    - Polling의 주기가 짧으면 서버 성능에 부담, 길어지면 실시간성 ↓

  - **하드웨어적 방법(Vectored Interrupt)**

    - 인터럽트를 요청할 수 있는 장치와 CPU 사이에 장치번호를 식별할 수 있는 **버스를 직렬/병렬로 연결**
    - 인터럽트 벡터는 인터럽트를 발생한 장치가 분기할 곳에 대한 정보
    - SW적 방법에 비해 비경제적
    - 회로 복잡, 융통성 없음, 별도의 SW 필요없이 HW로 처리 -> 속도가 빠름

    1. `Daisy Chain`
       - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결
       - 우선순위가 높은 장치를 상위에 두고 우선순위 차례대로 배치
    2. `병렬(Parallel) 우선순위 부여 방식`
       - 인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결
       - 각 장치별 우선순위를 판별하기 위한 Mask register에 bit 설정
       - Mask register 상 우선순위가 높은 서비스 루틴 수행 중 우선순위가 낮은 bit들을 비활성화 가능
       - 반대로 우선순위가 높은 인터럽트는 낮은 인터럽트 수행 중에도 우선 처리





------

- 인터럽트 핸들러
  - 실제 인터럽트 처리를 위한 루틴
- 인터럽트 벡터
  - 인터럽트 발생 시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하는 테이블
- PCB(Process Control Block)
  - 커널의 데이터 영역에 존재
  - 각각의 프로세스마다 고유의 PCB 존재
  - 인터럽트 발생 시 프로세스의 어느 부분이 수행중이었는지 저장(수행중이던 메모리 주소, 레지스터 값, 하드웨어 상태 ..)

