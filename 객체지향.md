#### 객체지향 프로그래밍(Object Oriented Programming)

-------------------------------------

`문제를 여러 개의 객체 단위로 나눠 작업하는 방식`

`객체들이 서로 유지적으로 상호작용하는 프로그래밍 이론`

cf) `객체` = 세상에 존재하는 모든 것, 프로그래밍에서의 객체는 데이터의 분산을 막기 위해 `데이터와 기능을 하나로 묶은 그룹`

ex) 컴퓨터(객체) = 데이터(본체, 모니터, 키보드, 마우스 등) + 기능(화면, 소리, 입력, 출력 등)



````
인간 중심적 프로그래밍 패러다임
= 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것
= 현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍하는 것 => `추상화`
````





- **장점**
  - OOP로 코드를 작성하면 이미 작성한 코드에 대한 **재사용성**이 높다
    - 자주 사용되는 로직을 라이브러리로 만들어두면 계속 해서 사용 가능, 그 신뢰성 확보 가능
    - 상속을 통해 코드의 재사용성을 높일 수 있다
  - 라이브버리를 각종 예외 상황에 맞게 잘 만들어두면 → 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다
  - 내부적으로 어떻게 동작하는지 몰라도 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 **생산성이 높아진다**
  - 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 **유지보수에 용이**
    - 프로그램 수정 시 추가, 수정을 하더라도 캡슐화를 통해 주변 영향이 적기 때문에 유지보수가 쉬워 매우 경제적
  - 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 가능
    - 우리 일상 생활의 모습의 구조가 객체에 자연스레 녹아들어 있기 때문에 생각하고 있는 것을 그대로 자연스럽게 구현할 수 있다

<b>

- **단점**
  - 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 **많은 오버헤드 발생** => But, 하드웨어의 발전으로 많은 부분 보완됨
  - 객체가 생태를 갖는다 → 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 애플리케이션 내부에서 버그 발생
  - 개발 속도가 느려짐
    - 객체가 처리하려는 것에 대한 정확한 이해 필요 → 설계 단계부터 많은 시간이 소모됨





- **특징**

  - 가장 큰 특징 

    `클래스 이용` → 연관있는 처리 부분(함수)과 데이터 부분(변수)을 하나의 객체(인스턴스)로 묶어 생성해 사용한다는 점

  1. 캡슐화(Encapsulation)

     - 데이터와 코드의 형태를 외부로부터 알 수 없게 데이터의 구조와 역할, 기능을 하나의 캡슐 형태로 만드는 방법

     - 캡슐화의 중요한 목적 

       - 변수를 private로 선언해 데이터 보호
       - 보호된 변수는 setter나 getter등의 메소드를 통해서만 간접적 접근 허용

     - 캡슐화 시 불필요한 정보를 감출 수 있기 때문에 → 정보은닉을 할 수 있다

       

  2. 추상화

     - 객체의 공통적인 속성과 기능을 추출하여 정의하는 것 = 실제 존재하는 객체들을 프로그램으로 만들기 위해 공통 특성을 파악해 필요없는 특성을 제거하는 과정

       ex) 객체들은 실제 그 모습이지만, 클래스 → 객체들이 어떤 특징들이 있어야 한다고 정의하는 추상화된 개념

     - `객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법`

       

  3. 상속

     - 기존 상위클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클래스에 새로운 기능도 추가할 수 있는 것

     - 부모 클래스, 자식 클래스

     - **코드의 중복을 없애기 위해** 필요

       - 코드의 중복이 많아지면 개발 단계와 유지 보수에 많은 비용이 들게 됨

     - 상속 관계를 맺으면 → 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없다

       

  4. 다형성

     - 상속과 연관있는 개념 → 한 객체가 상속을 통해 기능을 확장하거나 변경하여 다른 여러 형태(객체)로 재구성 되는 것 (= 한 부모의 밑에서 태어난 자식들이 조금씩 다르다)
       - `오버라이딩`
         - 하위 클래스가 **상위 클래스에서 만들어진 메서드를 자신의 입맛대로 다시 재창조**해서 사용하는 것
       - `오버로딩`
         - 하나의 클래스 안에서 **같은 이름의 메서드를 사용하지만 각 메서드마다 다른 용도**로 사용되며 그 결과물도 다르게 구현
         - 메소드마다 이름은 같지만 매개변수의 개수나 데이터 타입이 달라야 한다
     - 같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고 메서드 이름을 낭비하지 않는다
       - 코드 재사용성을 늘려주어 유지보수가 용이하도록 도와주는 개념



--------------------------------------

어떤 대상을 `추상화`하여 **공통점**을 찾고, `캡슐화`해 한 군데에 모아 **객체를 만들고**, 새로운 객체가 `상속`받아 **재사용**이 가능하게 만들어준다.

상속받은 객체는 `다형성`을 통해 기능을 수정 또는 추가하여 재사용할 수 있다.

----------------------------------------





[참고 링크]: https://velog.io/@gillog/OOP%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

