### 불변 객체(Immutable Object)

<br>

:heavy_check_mark: `변하지 않는 객체`

- 객체가 생성된 후 내부 상태가 변하지 않는 객체 

- 멀티 스레드 환경에서도 안전하게 사용하여 신뢰성 보장

  ex) String .. 

<br>

:heavy_check_mark: cf) **가변객체**

- Java에서 클래스에 인스턴스가 생성된 이후 내부 상태가 변경 가능한 객체
- 멀티 스레드 환경에서 사용하려면 동기화 처리가 필요
- ex)  ArrayList, HashMap, StringBuilder, StringBuffer

<br>

:heavy_check_mark: **장점**

1. Thread-Safe하여 병렬 프로그래밍에 유용, 동기화를 고려하지 않아도 된다

   - 멀티 스레드 환경에서 동기화 문제가 발생하는 이유 = 공유 자원에 동시 쓰기 연산을 하기 때문!

   - But, 공유 자원 불변 객체라면 항상 동일한 값 반환 → 동기화를 고려할 필요 X

   - 이는 **안전성을 보장**할 뿐 아니라 동기화를 하지 않음으로써 **성능상의 이점**도 가져다 줌

     <br>

2. 실패 원자적(Failure Atomic) 메소드를 만들 수 있다

   - 가변 객체를 통해 작업을 하는 도중 예외 발생 시 → 객체가 불안정한 상태에 빠질 수 있고, 불안정한 상태를 갖는 객체는 또 다른 에러 유발 가능

   - But, 불변 객체라면 어떠한 **예외가 발생하여도** 메서드 **호출 전의 상태 유지 가능**

     - 예외가 발생하여도 오류가 발생하지 않을 것처럼 다음 로직 처리 가능

     <br>

3. Cache, Map, Set 등의 요소로 활용하기에 적합

   - 만약, 캐시나 맵, set으로 사용되는 객체가 변할 시 이를 갱신하는 작업이 필요

   - But, 객체가 불변이라면 한 번 데이터가 저장된 후 다른 부가 작업을 고려하지 않아도 됨

     <br>

4. 부수 효과(Side Effect)를 피해 오류 가능성 최소화

   - 부수 효과 

     - 변수의 값이 변경되거나, 필드 값이 설정되는 등의 변화가 발생하는 효과

   - 만약, 객체의 Setter가 구현되어 있고 여러 메소드에서 객체의 값이 변경된다면 객체를 예측하기 어려워짐

     - 이러한 부수 효과가 없는 순수 함수를 만드는 것이 중요

   - But, 객체가 불변이라면 불변 객체는 기본적으로 값의 수정이 불가능하므로 변경 가능성이 적고 객체의 생성과 사용이 제한됨

     - 메소드들은 자연스럽게 순수 함수로 구성될 것이고 다른 메소드가 호출되어도 객체의 상태가 유지됨 → 객체를 안전하게 재사용 가능 
     - 이러한 불변 객체는 오류를 줄여 유지보수성이 높은 코드를 작성하게 도와줌

     <br>

5. 다른 사람이 작성한 함수를 예측 가능하며 안전하게 사용할 수 있다

   - 변경에 대한 불안없이 다른 사람의 코드를 이용할 수 있다

     <br>

6. 가비지 컬렉션의 성능을 높일 수 있다

   - 불변 객체를  한번 메모리에 할당하게 되면 같은 객체를 계속 호출하여도, 새롭게 할당되지 않아도 되므로 GC의 성능을 높일 수 있다

   <br>



**:heavy_check_mark: 불변 객체를 만드는 방법**

- 불변 객체는 read-only 메소드만 제공 (Setter 메소드 제공 X)
- 객체의 내부 상태를 알려주는 메소드를 제공하지 않거나 제공할 경우 방어적 복사 혹은 Unmodified 라이브러리를 통해 제공
- 객체의 필드는 모두 `final`을 사용하여 처음 할당된 이후 상태가 바뀌지 않도록 설정해야 함
  - 다만, 무조건 final을 필드에 붙인다고 해당 객체를 불변 객체라고 부를 수 있는 것은 아님

<br>

1. 필드가 모두 primitive type인 경우
   - 원시 타입은 참조 값이 존재하지 않기 때문에 값을 그대로 외부로 내보내는 경우에도 내부 객체는 불변 
     - setter가 없고, 원시 타입 필드에 대해 final을 설정했다면 해당 객체는 불변 객체가 된다
2. 필드에 reference type이 있는 경우
   - 해당 참조 타입 객체도 불변 객체로 만들어야 한다
3. 필드에 불변 reference type 컬렉션이 있는 경우
   - 해당 필드를 그냥 넘겨주면 안되고 **방어적 복사를 거치고** 넘겨야 한다
     - ex) new ArrayList<>()와 같이 메모리를 새로 할당하여 기존 List와의 참조 주소를 끊어 내야 함
4. 필드에 가변 reference type 컬렉션이 있는 경우

<br>

````
1. setter 메소드 사용 X
2. 모든 필드를 final과 private를 사용해 선언 (Final Variable)
3. 클래스를 final로 선언해 overriding 막기 (final class)
4. 객체를 생성하기 위한 생성자 혹은 정적 팩토리 메소드 추가 (final method)
5. 인스턴스 필드에 가변 객체가 포함된다면 방어적 복사를 이용하여 전달
````

<br>

:heavy_check_mark: Final을 사용하는 이유

- 장점

  - 객체의 데이터를 참조할 때 데이터가 바뀔 걱정을 하지 않아도 됨

  - 멀티스레드 환경에서 동기화처리없이 사용 가능 

  - 방어 복사를 할 필요성이 없어짐

  - 프로그램의 안전성이 올라가는 코드 구현 가능

    <br>

- 단점

  - 새로운 객체를 생성해야 하므로 비용 발생

  <br>

  [불변객체 예제](https://kdg-is.tistory.com/223)

<br>

-----------------------------

https://steady-coding.tistory.com/559

https://dev-cool.tistory.com/23

https://kdg-is.tistory.com/223
