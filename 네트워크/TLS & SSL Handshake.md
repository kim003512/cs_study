### TLS/SSL HandShake

:heavy_check_mark: SSL Handshake

- 통신을 하는 **브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고 필요한 정보를 클라이언트와 서버가 주거니 받거니 하는 과정**이 악수와 비슷해 붙여진 이름

<br>

:heavy_check_mark: 대칭키 & 비대칭키

1. 대칭키(비밀키)
   - `하나의 키`로 데이터를 암호화, 복호화
   - 하나의 키로 암호화 및 복호화를 하기 때문에 해당 키가 노출된다면 보안상 아주 치명적 문제
   - 다만, 암호화 및 복호화에 드는 비용이 적다는 장점
   - 암호를 주고 받는 사람들 사이에 대칭키를 전달하는 것이 어렵다
     - 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화할 수 있기 때문
     - :arrow_forward: 이러한 배경에서 나온 암호화 방식이 바로 비대칭키 방식

<br>

2. 비대칭키(공개키)
   - `공개키와 개인키`로 암호화 및 복호화 수행
   - 공개키로 데이터를 암호화하면 반드시 개인키로만 복호화 가능, 개인키로 데이터를 암호화하면 공개키로만 복호화 가능
   - 개인키 = 비밀키 = 비공개키
   - 보안성이 좋지만, 구현이 어렵고 암호화 및 복호화 속도가 느림

<br>

:heavy_check_mark: 대칭키와 비대칭키의 혼합 사용

- SSL은 대칭키 방식과 비대칭키 방식을 섞어 사용
- [예제](https://steady-coding.tistory.com/512)

<br>

:heavy_check_mark: SSL Handshake 동작 과정

```
1. 서버는 CA에 사이트 정보와 공개키를 전달해 인증서를 받음
2. 클라이언트는 브라우저에 CA 공개키가 내장되어 있다고 가정
3. ClientHello(암호화 알고리즘 나열 및 전달)
4. ServerHello(암호화 알고리즘 선택)
5. Server Certificate(인증서 전달)
6. Client Key Exchange(데이터를 암호화할 대칭키 전달)
7. Client/ServerHello done(정보 전달 완료)
8. Finished(SSL Handshake 종료)
```

<br>

- CA
  - 인증서의 역할은 클라이언트가 접속한 서버가 의도한 서버가 맞는지를 보장하는 것
  - 이러한 역할을 하는 민간 기업들을 CA(Certificate Authority) 혹은 Root Certificate라 부름
  - 신뢰성이 엄격하게 공인된 기업들만 참여할 수 있음
  - 개발자 입장에서 HTTPS를 적용하려면 신뢰할 수 있는 CA 기업의 인증서를 구입해야 함
    - 이 인증서를 구입하게 되면 CA 기업의 개인 키를 이용하여 암호화한 인증서를 준다

<br>

- SSL 인증서
  - 서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)와 서버측 공개키가 들어있다
  - 일반적인 브라우저에 신뢰할 수 있는 CA 기관의 리스트와 해당 기관의 공개키를 가지고 있음
    - 클라이언트는 내장된 CA의 공개키를 활용해 인증서를 복호화함으로써 인증서를 검증한 뒤, 서버의 공개키를 가져올 수 있다

<br>

- ClientHello

  - 클라이언트가 서버에 연결을 시도하며 전송하는 패킷

  - 자신이 사용 가능한 Cipher Suite 목록, Session ID, SSL 프로토콜 버전, Random Byte 등을 전달

  - Cipher Suite는 SSL 프로토콜 버전, 인증서 검정, 데이터 암호화 프로토콜, Hash 방식 등의 정보를 담고 있는 존재로, 선택된 Cipher Suite의 알고리즘에 따라 데이터를 암호화

    ![image](https://user-images.githubusercontent.com/43842108/219036770-402a8097-650c-460c-9af5-a51a049c0c48.png)

<br>

- ServerHello
  - 서버는 클라이언트가 보내온 ClientHello 패킷을 받아 Cipher Suite 중 하나를 선택한 다음 클라이언트에게 이를 알린다
  - 자신의 SSL 프로토콜 버전 등도 같이 보낸다

<br>

- Certificate
  - 서버가 자신의 SSL 인증서를 클라이언트에게 전달
  - 인증서 내부에는 서버가 발행한 공개키(개인키는 따로 서버가 소유)가 들어있다
  - 클라이언트는 서버가 보낸 CA의 개인키로 암호화된 SSL 인증서를 이미 모두에게 공개된 CA의 공개키를 사용하여 복호화
  - 복호화에 성공하면 이 인증서가 CA에서 서명한 것이 맞으니 진짜임을 증명할 수 있다
  - 무슨 알고리즘으로 암호화, 무슨 Hash 알고리즘으로 서명되었는지 알 수 있다

<br>

- Server Key Exchange / ServerHello Done
  - 서버의 공개키가 SSL 인증서 내부에 없는 경우, 서버가 직접 전달한다는 뜻
  - 공개키가 SSL 인증서 내부에 있을 경우 Server Key Exchange는 생략
  - 인증서 내부에 서버의 공개키가 있다면 클라이언트가 CA의 공개키를 통해 인증서를 복호화한 후 서버의 공개키 확보 가능 -> 그리고 서버가 행동을 마쳤음을 전달

<br>

- Client Key Exchange
  - 클라이언트는 데이터 암호화에 사용할 대칭키를 생성한 후 SSL 인증서 내부에서 추출한 서버의 공개키를 이용해 암호화한 후 서버에게 전달
  - 여기서 전달된 대칭키가 SSL Handshake의 목적이자 가장 중요한 수단인 데이터를 실제로 암호화할 대칭키
  - 이 키를 통해 클라이언트와 서버가 실제로 교환하고자 하는 데이터를 암호화

<br>

- ChangeCipherSpec / Finished
  - 클라이언트와 서버 모두가 서로에게 보내는 패킷으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 다 되었음을 알리는 패킷
  - Finished 패킷을 보내어 SSL Handshake를 종료

<br>

