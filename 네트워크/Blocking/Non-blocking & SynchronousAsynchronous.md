### Blocking/Non-blocking & Synchronous/Asynchronous

:heavy_check_mark: Blocking

- 자신의 작업을 진행하다 다른 주체의 작업이 시작되면 **다른 작업이 끝날때까지 기다렸다 자신의 작업 시작**

<br>

:heavy_check_mark:NonBlocking

- **다른 주체의 작업에 관련없이 자신의 작업을 하는 것**

<br>

:heavy_check_mark:Synchronous

- 요청이 들어온 순서에 맞게 **하나씩** 처리

<br>

:heavy_check_mark:Asynchronous

- 하나의 요청이 끝나기도 전에, 다른 요청을 **동시에** 처리

<br>

:heavy_check_mark:Synchronous & Asynchronous

-  한 작업이 다른 작업을 호출하는 경우, 호출되는 함수의 작업 완료 여부를 누가 신경을 쓰는 지에 따라 나뉜다
- **순서와 결과의 관점**
- `Asynchronous`
  - **호출하는 함수가 작업 완료 여부를 신경쓰지 않음**
  - 호출하는 함수에게 Callback을 전달해 작업을 완료하면 실행하도록
  - 호출된 함수의 작업은 별도의 thread로 빼서 실행하며, 완료되면 호출한 함수에게 알려준다
- `Synchronous`
  - **호출하는 함수가 작업 완료 여부 확인**
  - 호출하는 함수는 호출되는 함수의 작업 완료 여부 또는 작업 완료 후 리턴을 기다림 or 주기적으로 물어본다

<br>

:heavy_check_mark: Blocking & Nonblocking

- 한 작업이 다른 작업을 호출하는 경우, 호출되는 함수가 바로 리턴을 하는지 여부에 따라 나뉜다
- 누구한테 **제어권(작업을 할 권리가) 있는 지가 관건**
- `Blocking`
  - 호출된 함수가 자신의 작업을 완료할때까지 리턴 :x:
  - 호출된 함수는 자신의 작업을 완료하면 호출한 함수에게 제어권을 넘겨주므로 호출한 함수는 다른 일을 하지 않고 대기
  - **제어권은 호출된 함수**에게 있다
- `Nonblocking`
  - 호출된 함수가 바로 리턴
  - 호출된 함수가 제어권을 바로 호출한 함수에게 넘겨주어 다른 일을 할 수 있도록 한다
  - **제어권은 호출한 함수**에게 있다

<br>

:heavy_check_mark:Sync-Blocking & Async-Nonblocking

![image](https://user-images.githubusercontent.com/43842108/219051913-a7a66773-4397-49a1-a3a3-ff0b0f2feb10.png)

- `Sync-Blocking`
  - 호출하는 함수는 호출된 함수의 작업 완료/리턴을 `기다림`
  - 호출된 함수는 자신의 작업이 완료되면 리턴
  - **호출한 함수는 함수를 호출한 후, 리턴을 받기 전까지 다른 일을 하지 않고 대기**

<br>

- `Async-Nonblocking`
  - 호출하는 함수는 호출된 함수의 작업 완료 및 리턴을 `기다리지 않는다`
  - **호출된 함수는 호출되면 바로 리턴**

<br>

- `Sync-Nonblocking`
  - 호출하는 함수는 호출된 함수의 작업 완료 및 리턴을 끝났는지 계속 기다린다
  - 호출된 함수는 호출되면 바로 리턴
  - **호출한 함수는 호출 이후 제어권을 바로 받기 때문에 작업을 계속하면서, 호출했던 함수의 작업 완료는 주기적으로 확인**

<br>

- `Asynchronous-Blocking`
  - 호출하는 함수는 호출된 함수의 작업 완료 및 리턴을 기다리지 않는다
    - 호출된 함수는 자신의 작업이 끝날때까지 제어권을 넘겨주지 않기 때문에 호출된 함수의 작업이 완료될때까지 대기하게 된다
    - Sync-Blocking과 유사하게 동작
  - 호출된 함수는 자신의 작업이 완료되면 리턴

<br>

:heavy_check_mark:I/O 작업

- 입출력 작업은 커널 레벨에서만 수행할 수 있으므로 프로세스 및 스레드는 커널에게 I/O 요청
  - 프로세스 및 스레드 = 호출하는 함수
  - I/O 작업 = 호출되는 함수

<br>

:heavy_check_mark:I/O Blocking

- 프로세스 및 스레드가 커널에게 I/O를 요청하는 함수 호출
- `커널 작업 완료`
  - 커널 작업 중에 프로세스/스레드는 자신의 작업을 중단하고 대기
  - 커널 작업 중 CPU 자원을 쓰지 않으므로 자원 낭비가 심하다
- 작업 결과 리턴
- cf
  - 여러 클라이언트가 접속하는 서버인 경우, I/O 작업을 호출한 작업은 중지되어도 다른 클라이언트가 실행하는 작업은 중지되면 안되기 때문에 클라이언트 별로 스레드를 생성하게 되어 클라이언트의 수가 매우 많아진다

<br>

:heavy_check_mark:I/O Nonblocking

- 프로세스 및 스레드가 커널에게 I/O를 요청하는 함수 호출
- `커널은 곧바로 리턴`
- 커널 작업이 완료되면 데이터를 리턴
- 커널 작업 중에 프로세스/스레드는 자신의 작업을 진행
